/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import e from"./Error.js";import{L as t}from"../chunks/Logger.js";import{i as n,b as r,a as o,r as i}from"./lang.js";import"../chunks/object.js";import"../config.js";import"../chunks/string.js";const c=(s=globalThis,{setTimeout:(e,t)=>{const n=s.setTimeout(e,t);return{remove:()=>s.clearTimeout(n)}}});var s;function u(e){return e&&("function"==typeof e.on||"function"==typeof e.addEventListener)}function l(e,t,n){if(!u(e))throw new TypeError("target is not a Evented or EventTarget object");if("on"in e)return e.on(t,n);if(Array.isArray(t)){const r=t.slice();for(const t of r)e.addEventListener(t,n);return{remove(){for(const t of r)e.removeEventListener(t,n)}}}return e.addEventListener(t,n),{remove(){e.removeEventListener(t,n)}}}function f(e,t,n){if(!u(e))throw new TypeError("target is not a Evented or EventTarget object");if("once"in e)return e.once(t,n);const r=l(e,t,(t=>{r.remove(),n.call(e,t)}));return{remove(){r.remove()}}}function a(e,t,n){let r=!1;const o=l(e,t,(t=>{r||n.call(e,t)}));return{resume(){r=!1},pause(){r=!0},remove(){o.remove()}}}const m={Win:"Meta",Scroll:"ScrollLock",Spacebar:" ",Down:"ArrowDown",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Del:"Delete",Apps:"ContextMenu",Esc:"Escape",Multiply:"*",Add:"+",Subtract:"-",Decimal:".",Divide:"/"};function h({key:e}){return m[e]||e}function p(e){return Promise.all(e)}function v(e,t){const n=e.slice();return Promise.all(e.map(((e,n)=>t(e,n)))).then((e=>n.filter(((t,n)=>e[n]))))}function w(e){return new Promise(((t,n)=>{try{e(t,n)}catch(e){Promise.resolve().then((()=>n(e)))}}))}function b(t="Aborted"){return new e("AbortError",t)}function d(e,t="Aborted"){if(E(e))throw b(t)}function g(e){return n(e)?"aborted"in e?e:e.signal:e}function E(e){const t=g(e);return n(t)&&t.aborted}function j(e){if(D(e))throw e}function A(e){if(!D(e))throw e}function T(e,t){const n=g(e);if(!r(n)){if(!n.aborted)return f(n,"abort",(()=>t()));t()}}function y(e,t){const n=g(e);if(!r(n))return d(n),f(n,"abort",(()=>t(b())))}function P(e,t){const n=g(t);return r(n)?e:new Promise(((n,r)=>{let o=T(t,(()=>r(b())));const c=()=>o=i(o);e.then(c,c),e.then(n,r)}))}function L(t,n){return Promise.race([t,O(n).then((()=>{throw new e("timeout",`Did not resolve within ${n} milliseconds`)}))])}function D(e){return e&&"AbortError"===e.name}function k(e){return e.catch((e=>{if(!D(e))throw e}))}function C(e,n=t.getLogger("esri")){return e.catch((e=>{D(e)||n.error(e)}))}function S(){let e=null;const t=new Promise(((t,n)=>{e={promise:void 0,resolve:t,reject:n}}));return e.promise=t,e}function M(e){if(!e)return;if("function"!=typeof e.forEach){const t=Object.keys(e);return M(t.map((t=>e[t]))).then((e=>{const n={};return t.forEach(((t,r)=>n[t]=e[r])),n}))}const t=e;return w((e=>{const n=[];let r=t.length;0===r&&e(n),t.forEach((t=>{const o={promise:t||Promise.resolve(t)};n.push(o),o.promise.then((e=>{o.value=e})).catch((e=>{o.error=e})).then((()=>{--r,0===r&&e(n)}))}))}))}function U(e){return M(e).then((e=>e.filter((e=>!!e.value)).map((e=>e.value))))}function x(e){return Promise.reject(e)}function R(e){return Promise.resolve(e)}function O(e,t,n){const r=new AbortController;return T(n,(()=>r.abort())),new Promise(((n,o)=>{let i=setTimeout((()=>{i=0,n(t)}),e);T(r,(()=>{i&&(clearTimeout(i),o(b()))}))}))}function W(t,n,r,o){const i=r&&"abort"in r?r:null;null!=o||i||(o=r);let c=setTimeout((()=>{c=0,i&&i.abort()}),n);const s=()=>o||new e("promiseUtils:timeout","The wrapped promise did not resolve within "+n+" ms");return t.then((e=>{if(0===c)throw s();return clearTimeout(c),e}),(e=>{throw clearTimeout(c),0===c?s():e}))}function $(e){return e&&"function"==typeof e.then}function q(e){return z(e)?e:Promise.resolve(e)}function z(e){return e&&"object"==typeof e&&"then"in e&&"function"==typeof e.then}function B(e,t=-1){let n,r,i,c,s=null;const u=(...l)=>{if(n){r=l,c&&c.reject(b()),c=S();const e=o(c.promise);if(s){const e=s;s=null,e.abort()}return e}if(i=c||S(),c=null,t>0){const r=new AbortController;n=q(e(...l,r.signal));const o=n;O(t).then((()=>{n===o&&(c?r.abort():s=r)}))}else n=1,n=q(e(...l));const f=()=>{const e=r;r=i=n=s=null,null!=e&&u(...e)},a=n,m=i;return a.then(f,f),a.then(m.resolve,m.reject),o(m.promise)};return u}function F(){let e,t;const n=new Promise(((n,r)=>{e=n,t=r})),r=t=>{e(t)};return r.resolve=t=>e(t),r.reject=e=>t(e),r.timeout=(e,t)=>c.setTimeout((()=>r.reject(t)),e),r.promise=n,r}function G(e,t){return e.then(t,t)}function H(e,t){let r,o=new AbortController;const i=e(o.signal);let c={promise:i,finished:!1,abort:()=>{o&&(o.abort(),o=null)}};const s=()=>{c&&(c.finished=!0,c=null),n(r)&&(r.remove(),r=null),o=null};return i.then(s,s),r=T(t,(()=>{n(c)&&c.abort()})),c}function I(e){return Promise.resolve().then((()=>{d(e)}))}export{O as after,p as all,G as always,c,w as create,b as createAbortError,S as createDeferred,F as createResolver,H as createTask,B as debounce,h as e,M as eachAlways,U as eachAlwaysValues,v as filter,u as i,k as ignoreAbortErrors,D as isAbortError,E as isAborted,z as isPromise,$ as isPromiseLike,C as logOnError,l as o,T as onAbort,y as onAbortOrThrow,a as p,x as reject,R as resolve,j as throwIfAbortError,d as throwIfAborted,A as throwIfNotAbortError,W as timeout,I as waitTick,q as when,P as whenOrAbort,L as whenOrTimeout};
